<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Mechamarkers</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }

      body {
        font-family: sans-serif;
        font-size: 12px;
        line-height: 1.5;
        overflow: hidden;
        background: rgb(66, 66, 66);
      }
    </style>
    <script src="./build/app.js"></script>
  </head>

  <body>
    <canvas class = "canvas"></canvas>

    <img src = "https://images-na.ssl-images-amazon.com/images/I/81FAXirfJUL.png" id = "speedo" style = "display:none !important"/>
    <img src = "https://previews.123rf.com/images/dariy/dariy1612/dariy161200020/69684345-old-radio-isolated-on-white-background-style-50-ies-of-the-19th-century.jpg" id = "radio" style = "display:none !important"/>

    <script src="https://js.leapmotion.com/leap-0.6.4.js"></script>
    <script src="https://js.leapmotion.com/leap-plugins-0.1.12.js"></script>

    <!--for Testing leap Motion-->
    <h1>Testing Leap JS</h1>
    <div id="output"></div>
    
    <script>
      // Make included libraries local
      const Mechamarkers = window.Mechamarkers;
      const Vec2 = window.Vec2;

      let prevTime;
      var states = [
        [300,300,-3],
        [300,300,-3]
      ]
      //----------Leap Motion Stuff-------------------------------------------------
      function concatData(id, data) {
        return id + ": " + data + "<br>";
      }

      var output = document.getElementById('output');
      var frameString = "", handString ="", fingerString = "";
      var hand, finger;

      //leap.loop uses browser's requestAnimationFrame
      var options = { enableGestures: true};
      //main leap loop
      Leap.loop(options, function(frame) {
        //prints frame id and data
        frameString = concatData("frame_id", frame.id);
        frameString += concatData("num_hands", frame.hand.length);
        frameString += concatData("num_fingers", frame.finger.length);
        frameString += "<br>";

        output.innerHTML = frameString;
      });
      //-------------------------End Leap motion Stuff------------------------------
      
      // This function is called every animation frame (roughly 60 times a second)
      function update() 
      {
        // Keep track of time between updates as dt (delta time)
        const currTime = Date.now();
        const dt = (currTime - prevTime) / 1000;
        prevTime = currTime;

        // Update the mechamarkers library
        Mechamarkers.update(currTime);

        //Uncomment to display image
        marker11_pos = Mechamarkers.getMarker(11).center
        marker10_pos = Mechamarkers.getMarker(10).center
        
        //If not input group detected, will be NULL
        var remote = null

        // If the group doesn't exist in the config or the config is not loaded
        // undefined will be returned, you can work around this with a simple if
        if (Mechamarkers.getGroup('remote')) 
        {
          remote = Mechamarkers.getGroup('remote')
        }

        // If you wanted to use a canvas to draw stuff, I would put that code here
        draw(remote, marker11_pos, marker10_pos);

        //Keep this at the end. It triggers the loop to continue
        window.requestAnimationFrame(update);
      }


      //Helper function to get degrees from radians
      function radToDeg(radian)
      {
        return radian * 57.29
      }

      //Helper function to do rotations
      function drawImageRot(img, x, y, width, height, deg)
      {
        // Store the current context state (i.e. rotation, translation etc..)
        ctx.save()

        //Convert degrees to radian 
        var rad = deg * Math.PI / 180;

        //Set the origin to the center of the image
        ctx.translate(x + width / 2, y + height / 2);

        //Rotate the canvas around the origin
        ctx.rotate(rad);

        //draw the image    
        ctx.drawImage(img,width / 2 * (-1),height / 2 * (-1),width,height);

        // Restore canvas state as saved from above
        ctx.restore();
      }

      //INPUTS:
        //Remote is a group object that contains multiple inputs
      function draw(remote, marker_11, marker_10)
      {
        //???
        ctx.clearRect(-1, -1, canvas.width + 1, canvas.height + 1)
        ctx.fillStyle = 'black'

        var speedo_img = document.getElementById("speedo")
        var radio_img = document.getElementById("radio")
       
        //Uncomment to display image
        //ctx.drawImage(speedo_img, marker11_pos.x, marker11_pos.y, 300, 300)
        //ctx.drawImage(radio_img, marker10_pos.x, marker10_pos.y, 300, 300)
        
        //If remotes present
        if (remote)
        {
          //Point I'm projecting from
          var anchor = remote.anchor.center

          //Image scale, select, and rotate
          var scale = remote.getInput("scale") //Grabs the scale input object
          var select = remote.getInput("select") //Grabs the select input object
          var rotate = remote.getInput("rotate") //Grabs the scale input object

          //Image size
          //Based on current value of slider
          var img_size = 300 * scale.val

          //Image rotation
          var img_rotation = radToDeg(rotate.val + 3.14)

          //ctx.drawImage(speedo_img, anchor.x, anchor.y, img_size , img_size)

          //Draws the image onto the canvas (DRAWS ANCHOR)
          //drawImageRot(speedo_img, anchor.x, anchor.y, img_size, img_size, img_rotation)

          var selected_img = ""
          
          if (select.val < .5) 
          {
            drawImageRot(speedo_img, marker_10.x, marker_10.y, img_size, img_size, img_rotation)
            drawImageRot(radio_img, marker_11.x, marker_11.y, states[0][0], states[0][1], radToDeg(states[0][2]+ 3.14))
            states[1][0] = img_size
            states[1][1] = img_size
            states[1][2] = rotate.val
          }
          else 
          {
            drawImageRot(radio_img, marker_11.x, marker_11.y, img_size, img_size, img_rotation)
            drawImageRot(speedo_img, marker_10.x, marker_10.y, states[1][0], states[1][1], radToDeg(states[0][2]+ 3.14))
            states[0][0] = img_size
            states[0][1] = img_size
            states[0][2] = rotate.val
          }
        }
      }
      
      // Onload is called when the window loads
      window.onload = () => 
      {
        prevTime = Date.now();

        canvas = document.querySelector('canvas')
        ctx = canvas.getContext('2d')
        
        // This line initializes mechamarkers library
        //I ADDED CANVAS AND CTX
        Mechamarkers.init(canvas, ctx);

        //I ADDED BOTH BELOW
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight

        // Begin the update loop
        update();
      }

    </script>
  </body>
</html>
