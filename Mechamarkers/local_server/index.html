<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Mechamarkers</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }

      body {
        font-family: sans-serif;
        font-size: 12px;
        line-height: 1.5;
        overflow: hidden;
        background: rgb(0, 0, 0);
      }
    </style>
    <script src="./build/app.js"></script>
  </head>

  <body>
    <canvas class = "canvas"></canvas>

    <img src = "https://images-na.ssl-images-amazon.com/images/I/81FAXirfJUL.png" id = "speedo" style = "display:none">

    <script>
      // Make included libraries local
      const Mechamarkers = window.Mechamarkers;
      const Vec2 = window.Vec2;

      let prevTime;

      // This function is called every animation frame (roughly 60 times a second)
      function update()
      {
        // Keep track of time between updates as dt (delta time)
        const currTime = Date.now();
        const dt = (currTime - prevTime) / 1000;
        prevTime = currTime;

        // Update the mechamarkers library
        Mechamarkers.update(currTime);

        //Getting center positions of mechamarkers
        marker11_pos = Mechamarkers.getMarker(11).center
        marker10_pos = Mechamarkers.getMarker(10).center

        //If not input group detected, will be NULL
        var remote = null

        // If the group doesn't exist in the config or the config is not loaded
        // undefined will be returned, you can work around this with a simple if
        if (Mechamarkers.getGroup('remote'))
        {
          remote = Mechamarkers.getGroup('remote')
        }

        // If you wanted to use a canvas to draw stuff, I would put that code here
        draw(remote);

        //Keep this at the end. It triggers the loop to continue
        window.requestAnimationFrame(update);
      }


      //Helper function to get degrees from radians
      function radToDeg(radian)
      {
        return radian * 57.29
      }

      //Helper function to do rotations
      function drawImageRot(img, x, y, width, height, deg)
      {
        // Store the current context state (i.e. rotation, translation etc..)
        ctx.save()

        //Convert degrees to radian
        var rad = deg * Math.PI / 180;

        //Set the origin to the center of the image
        ctx.translate(x + width / 2, y + height / 2);

        //Rotate the canvas around the origin
        ctx.rotate(rad);

        //draw the image
        ctx.drawImage(img,width / 2 * (-1),height / 2 * (-1),width,height);

        // Restore canvas state as saved from above
        ctx.restore();
    }

      //INPUTS:
        //Remote is a group object that contains multiple inputs
      function draw(remote)
      {
        //???
        ctx.clearRect(-1, -1, canvas.width + 1, canvas.height + 1)
        ctx.fillStyle = 'black'

        var speedo_img = document.getElementById("speedo")

        //Draw graphics

      //  drawRadio("Channel 12",ctx, marker10_pos.x, marker10_pos.y+100,300,100);
        drawRadio("Sirius XM 26",ctx, 300, 300,300,100);
        drawSpeedometer("hello", ctx, 500,500, 80);
        drawClimate("67", "85",ctx, 450, 200, 300, 100);

        //test to see if the local server is working. will draw the speedometer
        // ctx.drawImage(speedo_img, 100,100, 300, 300)

        //Uncomment to display image
        //ctx.drawImage(speedo_img, marker11_pos.x, marker11_pos.y, 300, 300)

        //If remotes present
        if (remote)
        {
        //console.log("here");
          //Point I'm projecting from
          var anchor = remote.anchor.center

          //Image scale, select, and rotate
          var scale = remote.getInput("scale") //Grabs the scale input object
          console.log("NUM:", scale.val)
          var select = remote.getInput("select") //Grabs the select input object
          var rotate = remote.getInput("rotate") //Grabs the scale input object

          //Image size
          //Based on current value of slider
          var img_sizeX = 300 * scale.val
          var img_sizeY= 100*scale.val

          //Image rotation
          var img_rotation = radToDeg(rotate.val + 3.14)
          //var img_rotation = rotate.val + 3.14
          console.log(img_rotation)

          canvas.font = '20px arial';
          //Draws the image (image, x, y, width, height)
          //ctx.drawImage(speedo_img, anchor.x, anchor.y, img_size , img_size)

          drawRadio("Sirius XM 26",ctx, marker10_pos.x, marker10_pos.y,img_sizeX,img_sizeY);
          //Draws the image onto the canvas
          drawImageRot(speedo_img, anchor.x, anchor.y, img_size, img_size, img_rotation)
        }
      }

      //Draw the radio.
      function drawRadio(string, canvas, px, py, width, height)
      {

          canvas.strokeStyle = "rgb(255,255,255)";
          canvas.fillStyle='rgb(80,80,80)';
          canvas.fillRect(px,py, width,height);

          canvas.fillStyle='rgba(0, 0, 180)';
          canvas.fillRect(px +(.08*width),py+(.08*width), width/2,height/2);

          canvas.fillStyle ='#00CCFF';
          var fontSize= px +(.08*width);

          canvas.font = '20px arial';
          canvas.fillText(string, px +(.16*width),py+(.18*width));

          canvas.beginPath()
          canvas.arc(px +(.8*width), py+(.16*width), width/10, 0, Math.PI * 2, true); // Outer circle
          canvas.fillStyle = 'rgb(192,192,192)';
          canvas.fill();
          canvas.stroke();

          canvas.strokeStyle = "rgb(255,0,0)";
          canvas.beginPath();
          canvas.lineTo(px +(.8*width), py+(.16*width));
          canvas.lineTo(px+(.9*width), py+(.16*width));
          canvas.stroke();
        //  canvas.strokeRect(px +(.08*width),py+(.08*width), width/2,height/2);
      }

      //Draw the speedometer
      function drawSpeedometer(string, canvas, px, py, diam)
      {
        canvas.strokeStyle = "rgb(255,255,255)";
        canvas.beginPath();
        canvas.arc(px ,py, diam, 0, Math.PI * 2, true); // Outer circle
        canvas.fillStyle = 'rgb(105,105,105)';
        canvas.fill();
        canvas.stroke();

        canvas.fillStyle = 'rgb(255,255,255)';
        canvas.font = '15px arial';
        canvas.fillText(0, px-(diam*.6), py+(diam*.7), diam,1*Math.PI,1.5*Math.PI);
        canvas.fillText(20, px-(diam*.8), py+(diam*.2), diam,1*Math.PI,1.5*Math.PI);
        canvas.fillText(40, px-(diam*.7), py-(diam*.4), diam, 1*Math.PI, 1.5*Math.PI);
        canvas.fillText(60, px-(diam*.12), py-(diam*.7), diam, 1*Math.PI, 1.5*Math.PI);
        canvas.fillText(80, px+(diam*.5), py-(diam*.4), diam, 1*Math.PI, 1.5*Math.PI);
        canvas.fillText(100, px+(diam*.55), py+(diam*.2), diam, 1*Math.PI, 1.5*Math.PI);
        canvas.fillText(120, px+(diam*.35), py+(diam*.7), diam,1*Math.PI,1.5*Math.PI);

        canvas.beginPath();
        canvas.strokeStyle = "#FF0000";
        canvas.lineTo(px, py);
        canvas.lineTo(px-(diam*.6), py+(diam*.7));
        canvas.stroke();
      }

    //Draw the climate control
    function drawClimate(string, string2, canvas, px, py, width, height)
    {
      canvas.strokeStyle = "rgb(255,255,255)";
      canvas.fillStyle = 'rgb(120,120,120)';
      canvas.fillRect(px,py, width,height);

      canvas.beginPath();
      canvas.arc(px +(.85*width),py+(.16*width), width/10, 0, Math.PI * 2, true); // Outer circle
      var grd = canvas.createLinearGradient(px +(.85*width),py+(.32*width), px+(.85*width), py+(.02*width));
      grd.addColorStop(0, "red");
      grd.addColorStop(1, "blue");
      canvas.fillStyle = grd;
      canvas.fill();
      canvas.stroke();

      canvas.beginPath();
      canvas.arc(px +(.15*width),py+(.16*width), width/10, 0, Math.PI * 2, true); // Outer circle
      var grd = canvas.createLinearGradient(px +(.85*width),py+(.32*width), px+(.85*width), py+(.02*width));
      grd.addColorStop(0, "red");
      grd.addColorStop(1, "blue");
      canvas.fillStyle = grd;
      canvas.fill();
      canvas.stroke();

      canvas.beginPath();
      canvas.lineTo(px +(.85*width),py+(.16*width));
      canvas.lineTo(px+(.85*width), py+(.06*width));
      canvas.stroke();

      canvas.beginPath();
      canvas.lineTo(px +(.15*width),py+(.16*width));
      canvas.lineTo(px+(.05*width), py+(.16*width));
      canvas.stroke();

      canvas.fillStyle = 'rgb(0,0,180)';
      canvas.fillRect(px +(.3*width),py+(.08*width), width/2.5,height/2);

      // canvas.fillStyle = "rgb(255,255,255)";
      canvas.fillStyle ='#00CCFF';

      canvas.font = '20px serif';

      canvas.fillText(string, px +(.35*width) ,py+(.18*width));
      canvas.fillText(string2, px +(.6*width) ,py+(.18*width) );

    }


      // Onload is called when the window loads
      window.onload = () =>
      {
        prevTime = Date.now();

        canvas = document.querySelector('canvas')
        ctx = canvas.getContext('2d')

        // This line initializes mechamarkers library
        //I ADDED CANVAS AND CTX
        Mechamarkers.init(canvas, ctx);

        //I ADDED BOTH BELOW
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight

        // Begin the update loop
        update();
      }

    </script>
  </body>
</html>
