interface DefaultProps<T> {
    eventType: string;
    stop: () => void;
    currentTarget: T;
}
declare type NotFunction = {
    [k: string]: unknown;
} & ({
    bind?: never;
} | {
    call?: never;
});
declare type NoArguments = undefined | null | void | never;
declare type EventWithRestParam = ((evt: NotFunction, ...restParam: any[]) => any);
declare type EventDefinition = NotFunction | NoArguments | EventWithRestParam;
declare type EventMap = Record<string, EventDefinition>;
declare type EventKey<T extends EventMap> = string & keyof T;
declare type EventHash<T extends EventMap, S> = Partial<{
    [K in EventKey<T>]: EventCallback<T, K, S>;
}>;
declare type EventCallbackFirstParam<P, S> = P extends NoArguments ? DefaultProps<S> : P & DefaultProps<S>;
declare type EventCallbackFunction<T extends (...params: any[]) => any, S> = T extends (firstParam?: infer F, ...restParams: infer R) => any ? (firstParam: EventCallbackFirstParam<Required<F>, S>, ...restParams: R) => any : (firstParam: DefaultProps<S>) => any;
declare type EventCallback<T extends EventMap, K extends EventKey<T>, S> = T[K] extends (...params: any[]) => any ? EventCallbackFunction<T[K], S> : (event: EventCallbackFirstParam<T[K], S>) => any;
declare type EventTriggerFirstParam<T extends {}> = Pick<T, Exclude<keyof T, keyof DefaultProps<any>>> & Partial<DefaultProps<any>>;
declare type EventDiff<T, U> = T extends U ? never : T;
declare type EventTriggerPartialFunction<T extends (...params: any[]) => any> = T extends (firstParam: infer F, ...restParam: infer R) => any ? (firstParam?: EventTriggerFirstParam<EventDiff<F, undefined>>, ...restParams: R) => any : never;
declare type EventTriggerRequiredFunction<T extends (...params: any[]) => any> = T extends (firstParam: infer F, ...restParam: infer R) => any ? (firstParam: EventTriggerFirstParam<F>, ...restParams: R) => any : never;
declare type EventTriggerFunction<T extends (...params: any[]) => any> = Parameters<T> extends Required<Parameters<T>> & [any] ? EventTriggerRequiredFunction<T> : EventTriggerPartialFunction<T>;
declare type EventTriggerNoFunction<T> = T extends NoArguments ? (firstParam?: {
    [key: string]: never;
}) => any : EventTriggerFunction<(fisrtParam: EventTriggerFirstParam<T>) => any>;
declare type EventTriggerParams<T extends EventMap, K extends EventKey<T>> = Parameters<T[K] extends (...params: any[]) => any ? EventTriggerFunction<T[K]> : EventTriggerNoFunction<T[K]>>;
interface DefaultEventMap {
    [key: string]: (firstParam?: {
        [key: string]: any;
    }, ...restParams: any[]) => any;
}
declare class Component<T extends EventMap = DefaultEventMap> {
    static VERSION: string;
    options: {
        [key: string]: any;
    };
    private _eventHandler;
    constructor();
    trigger<K extends EventKey<T>>(eventName: K, ...params: EventTriggerParams<T, K>): boolean;
    once<K extends EventKey<T>>(eventName: K, handlerToAttach: EventCallback<T, K, this>): this;
    once(eventHash: EventHash<T, this>): this;
    hasOn<K extends EventKey<T>>(eventName: K): boolean;
    on<K extends EventKey<T>>(eventName: K, handlerToAttach: EventCallback<T, K, this>): this;
    on(eventHash: EventHash<T, this>): this;
    off(eventHash?: EventHash<T, this>): this;
    off<K extends EventKey<T>>(eventName: K, handlerToDetach?: EventCallback<T, K, this>): this;
}
export default Component;
