{"ast":null,"code":"/*\nCopyright (c) 2019 Daybrush\nname: @scena/dragscroll\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/dragscroll.git\nversion: 0.2.1\n*/\nimport Component from '@egjs/component';\nimport { now } from '@daybrush/utils';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nfunction getDefaultScrollPosition(e) {\n  var container = e.container;\n  return [container.scrollLeft, container.scrollTop];\n}\n\nvar DragScroll = /*#__PURE__*/function (_super) {\n  __extends(DragScroll, _super);\n\n  function DragScroll() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.startRect = null;\n    _this.startPos = [];\n    _this.prevTime = 0;\n    _this.timer = 0;\n    return _this;\n  }\n\n  var __proto = DragScroll.prototype;\n\n  __proto.dragStart = function (e, options) {\n    var _a = options.container.getBoundingClientRect(),\n        top = _a.top,\n        left = _a.left,\n        width = _a.width,\n        height = _a.height;\n\n    this.startPos = [e.clientX, e.clientY];\n    this.startRect = {\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    };\n  };\n\n  __proto.drag = function (e, options) {\n    var _this = this;\n\n    var clientX = e.clientX,\n        clientY = e.clientY;\n    var container = options.container,\n        _a = options.threshold,\n        threshold = _a === void 0 ? 0 : _a,\n        _b = options.throttleTime,\n        throttleTime = _b === void 0 ? 0 : _b,\n        _c = options.getScrollPosition,\n        getScrollPosition = _c === void 0 ? getDefaultScrollPosition : _c;\n\n    var _d = this,\n        startRect = _d.startRect,\n        startPos = _d.startPos;\n\n    var nowTime = now();\n    var distTime = Math.max(throttleTime + this.prevTime - nowTime, 0);\n    var direction = [0, 0];\n\n    if (startRect.top > clientY - threshold) {\n      if (startPos[1] > startRect.top || clientY < startPos[1]) {\n        direction[1] = -1;\n      }\n    } else if (startRect.top + startRect.height < clientY + threshold) {\n      if (startPos[1] < startRect.top + startRect.height || clientY > startPos[1]) {\n        direction[1] = 1;\n      }\n    }\n\n    if (startRect.left > clientX - threshold) {\n      if (startPos[0] > startRect.left || clientX < startPos[0]) {\n        direction[0] = -1;\n      }\n    } else if (startRect.left + startRect.width < clientX + threshold) {\n      if (startPos[0] < startRect.left + startRect.width || clientX > startPos[0]) {\n        direction[0] = 1;\n      }\n    }\n\n    clearTimeout(this.timer);\n\n    if (!direction[0] && !direction[1]) {\n      return false;\n    }\n\n    if (distTime > 0) {\n      this.timer = window.setTimeout(function () {\n        _this.drag(e, options);\n      }, distTime);\n      return false;\n    }\n\n    this.prevTime = nowTime;\n    var prevPos = getScrollPosition({\n      container: container,\n      direction: direction\n    });\n    this.trigger(\"scroll\", {\n      container: container,\n      direction: direction,\n      inputEvent: e\n    });\n    var nextPos = getScrollPosition({\n      container: container,\n      direction: direction\n    });\n    var offsetX = nextPos[0] - prevPos[0];\n    var offsetY = nextPos[1] - prevPos[1];\n\n    if (!offsetX && !offsetY) {\n      return false;\n    }\n\n    this.trigger(\"move\", {\n      offsetX: direction[0] ? offsetX : 0,\n      offsetY: direction[1] ? offsetY : 0,\n      inputEvent: e\n    });\n\n    if (throttleTime) {\n      this.timer = window.setTimeout(function () {\n        _this.drag(e, options);\n      }, throttleTime);\n    }\n\n    return true;\n  };\n\n  __proto.dragEnd = function () {\n    clearTimeout(this.timer);\n  };\n\n  return DragScroll;\n}(Component);\n\nexport default DragScroll;","map":{"version":3,"sources":["../src/DragScroll.ts"],"names":["container","e","__extends","_this","_a","top","left","width","height","clientX","clientY","_b","_c","_d","startRect","startPos","nowTime","now","distTime","Math","throttleTime","direction","clearTimeout","prevPos","getScrollPosition","inputEvent","nextPos","offsetX","offsetY"],"mappings":"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","sourcesContent":["import Component from \"@egjs/component\";\nimport { now } from \"@daybrush/utils\";\nimport { DragScrollOptions, Rect } from \"./types\";\n\nfunction getDefaultScrollPosition(e: { container: HTMLElement, direction: number[] }) {\n    const container = e.container;\n\n    return [\n        container.scrollLeft,\n        container.scrollTop,\n    ];\n}\n\nexport default class DragScroll extends Component {\n    private startRect: Rect | null = null;\n    private startPos: number[] = [];\n    private prevTime: number = 0;\n    private timer: number = 0;\n    public dragStart(e: any, options: DragScrollOptions) {\n        const {\n            top,\n            left,\n            width,\n            height,\n        } = options.container.getBoundingClientRect();\n\n        this.startPos = [e.clientX, e.clientY];\n        this.startRect = { top, left, width, height };\n    }\n    public drag(e: any, options: DragScrollOptions) {\n        const {\n            clientX,\n            clientY,\n        } = e;\n        const {\n            container,\n            threshold = 0,\n            throttleTime = 0,\n            getScrollPosition = getDefaultScrollPosition,\n        } = options;\n        const {\n            startRect,\n            startPos,\n        } = this;\n        const nowTime = now();\n        const distTime = Math.max(throttleTime + this.prevTime - nowTime, 0);\n\n        const direction = [0, 0];\n\n        if (startRect.top > clientY - threshold) {\n            if (startPos[1] > startRect.top || clientY < startPos[1]) {\n                direction[1] = -1;\n            }\n        } else if (startRect.top + startRect.height < clientY + threshold) {\n            if (startPos[1] < startRect.top + startRect.height || clientY > startPos[1]) {\n                direction[1] = 1;\n            }\n        }\n        if (startRect.left > clientX - threshold) {\n            if (startPos[0] > startRect.left || clientX < startPos[0]) {\n                direction[0] = -1;\n            }\n        } else if (startRect.left + startRect.width < clientX + threshold) {\n            if (startPos[0] < startRect.left + startRect.width || clientX > startPos[0]) {\n                direction[0] = 1;\n            }\n        }\n        clearTimeout(this.timer);\n\n        if (!direction[0] && !direction[1]) {\n            return false;\n        }\n        if (distTime > 0) {\n            this.timer = window.setTimeout(() => {\n                this.drag(e, options);\n            }, distTime);\n\n            return false;\n        }\n        this.prevTime = nowTime;\n        const prevPos = getScrollPosition({ container, direction });\n\n        this.trigger(\"scroll\", {\n            container,\n            direction,\n            inputEvent: e,\n        });\n\n        const nextPos = getScrollPosition({ container, direction });\n        const offsetX = nextPos[0] - prevPos[0];\n        const offsetY = nextPos[1] - prevPos[1];\n\n        if (!offsetX && !offsetY) {\n            return false;\n        }\n        this.trigger(\"move\", {\n            offsetX: direction[0] ? offsetX : 0,\n            offsetY: direction[1] ? offsetY : 0,\n            inputEvent: e,\n        });\n\n        if (throttleTime) {\n            this.timer = window.setTimeout(() => {\n                this.drag(e, options);\n            }, throttleTime);\n        }\n        return true;\n    }\n    public dragEnd() {\n        clearTimeout(this.timer);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}