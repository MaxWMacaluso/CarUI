{"ast":null,"code":"/*\nCopyright (c) 2019-present NAVER Corp.\nname: @egjs/list-differ\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-list-differ\nversion: 1.0.0\n*/\n\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nvar PolyMap = /*#__PURE__*/function () {\n  function PolyMap() {\n    this.keys = [];\n    this.values = [];\n  }\n\n  var __proto = PolyMap.prototype;\n\n  __proto.get = function (key) {\n    return this.values[this.keys.indexOf(key)];\n  };\n\n  __proto.set = function (key, value) {\n    var keys = this.keys;\n    var values = this.values;\n    var prevIndex = keys.indexOf(key);\n    var index = prevIndex === -1 ? keys.length : prevIndex;\n    keys[index] = key;\n    values[index] = value;\n  };\n\n  return PolyMap;\n}();\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\n\n\nvar HashMap = /*#__PURE__*/function () {\n  function HashMap() {\n    this.object = {};\n  }\n\n  var __proto = HashMap.prototype;\n\n  __proto.get = function (key) {\n    return this.object[key];\n  };\n\n  __proto.set = function (key, value) {\n    this.object[key] = value;\n  };\n\n  return HashMap;\n}();\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\n\n\nvar SUPPORT_MAP = typeof Map === \"function\";\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\n\nvar Link = /*#__PURE__*/function () {\n  function Link() {}\n\n  var __proto = Link.prototype;\n\n  __proto.connect = function (prevLink, nextLink) {\n    this.prev = prevLink;\n    this.next = nextLink;\n    prevLink && (prevLink.next = this);\n    nextLink && (nextLink.prev = this);\n  };\n\n  __proto.disconnect = function () {\n    // In double linked list, diconnect the interconnected relationship.\n    var prevLink = this.prev;\n    var nextLink = this.next;\n    prevLink && (prevLink.next = nextLink);\n    nextLink && (nextLink.prev = prevLink);\n  };\n\n  __proto.getIndex = function () {\n    var link = this;\n    var index = -1;\n\n    while (link) {\n      link = link.prev;\n      ++index;\n    }\n\n    return index;\n  };\n\n  return Link;\n}();\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\n\n\nfunction orderChanged(changed, fixed) {\n  // It is roughly in the order of these examples.\n  // 4, 6, 0, 2, 1, 3, 5, 7\n  var fromLinks = []; // 0, 1, 2, 3, 4, 5, 6, 7\n\n  var toLinks = [];\n  changed.forEach(function (_a) {\n    var from = _a[0],\n        to = _a[1];\n    var link = new Link();\n    fromLinks[from] = link;\n    toLinks[to] = link;\n  }); // `fromLinks` are connected to each other by double linked list.\n\n  fromLinks.forEach(function (link, i) {\n    link.connect(fromLinks[i - 1]);\n  });\n  return changed.filter(function (_, i) {\n    return !fixed[i];\n  }).map(function (_a, i) {\n    var from = _a[0],\n        to = _a[1];\n\n    if (from === to) {\n      return [0, 0];\n    }\n\n    var fromLink = fromLinks[from];\n    var toLink = toLinks[to - 1];\n    var fromIndex = fromLink.getIndex(); // Disconnect the link connected to `fromLink`.\n\n    fromLink.disconnect(); // Connect `fromLink` to the right of `toLink`.\n\n    if (!toLink) {\n      fromLink.connect(undefined, fromLinks[0]);\n    } else {\n      fromLink.connect(toLink, toLink.next);\n    }\n\n    var toIndex = fromLink.getIndex();\n    return [fromIndex, toIndex];\n  });\n}\n\nvar Result = /*#__PURE__*/function () {\n  function Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed) {\n    this.prevList = prevList;\n    this.list = list;\n    this.added = added;\n    this.removed = removed;\n    this.changed = changed;\n    this.maintained = maintained;\n    this.changedBeforeAdded = changedBeforeAdded;\n    this.fixed = fixed;\n  }\n\n  var __proto = Result.prototype;\n  Object.defineProperty(__proto, \"ordered\", {\n    get: function () {\n      if (!this.cacheOrdered) {\n        this.caculateOrdered();\n      }\n\n      return this.cacheOrdered;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"pureChanged\", {\n    get: function () {\n      if (!this.cachePureChanged) {\n        this.caculateOrdered();\n      }\n\n      return this.cachePureChanged;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  __proto.caculateOrdered = function () {\n    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);\n    var changed = this.changed;\n    var pureChanged = [];\n    this.cacheOrdered = ordered.filter(function (_a, i) {\n      var from = _a[0],\n          to = _a[1];\n      var _b = changed[i],\n          fromBefore = _b[0],\n          toBefore = _b[1];\n\n      if (from !== to) {\n        pureChanged.push([fromBefore, toBefore]);\n        return true;\n      }\n    });\n    this.cachePureChanged = pureChanged;\n  };\n\n  return Result;\n}();\n/**\n *\n * @memberof eg.ListDiffer\n * @static\n * @function\n * @param - Previous List <ko> 이전 목록 </ko>\n * @param - List to Update <ko> 업데이트 할 목록 </ko>\n * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>\n * @return - Returns the diff between `prevList` and `list` <ko> `prevList`와 `list`의 다른 점을 반환한다.</ko>\n * @example\n * import { diff } from \"@egjs/list-differ\";\n * // script => eg.ListDiffer.diff\n * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1], e => e);\n * // List before update\n * // [1, 2, 3, 4, 5]\n * console.log(result.prevList);\n * // Updated list\n * // [4, 3, 6, 2, 1]\n * console.log(result.list);\n * // Index array of values added to `list`\n * // [0, 1, 5]\n * console.log(result.added);\n * // Index array of values removed in `prevList`\n * // [5]\n * console.log(result.removed);\n * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.changed);\n * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n * // [[4, 3], [3, 4], [2, 6]]\n * console.log(result.pureChanged);\n * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n * // [[4, 1], [4, 2], [4, 3]]\n * console.log(result.ordered);\n * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.maintained);\n */\n\n\nfunction diff(prevList, list, findKeyCallback) {\n  var mapClass = SUPPORT_MAP ? Map : findKeyCallback ? HashMap : PolyMap;\n\n  var callback = findKeyCallback || function (e) {\n    return e;\n  };\n\n  var added = [];\n  var removed = [];\n  var maintained = [];\n  var prevKeys = prevList.map(callback);\n  var keys = list.map(callback);\n  var prevKeyMap = new mapClass();\n  var keyMap = new mapClass();\n  var changedBeforeAdded = [];\n  var fixed = [];\n  var removedMap = {};\n  var changed = [];\n  var addedCount = 0;\n  var removedCount = 0; // Add prevKeys and keys to the hashmap.\n\n  prevKeys.forEach(function (key, prevListIndex) {\n    prevKeyMap.set(key, prevListIndex);\n  });\n  keys.forEach(function (key, listIndex) {\n    keyMap.set(key, listIndex);\n  }); // Compare `prevKeys` and `keys` and add them to `removed` if they are not in `keys`.\n\n  prevKeys.forEach(function (key, prevListIndex) {\n    var listIndex = keyMap.get(key); // In prevList, but not in list, it is removed.\n\n    if (typeof listIndex === \"undefined\") {\n      ++removedCount;\n      removed.push(prevListIndex);\n    } else {\n      removedMap[listIndex] = removedCount;\n    }\n  }); // Compare `prevKeys` and `keys` and add them to `added` if they are not in `prevKeys`.\n\n  keys.forEach(function (key, listIndex) {\n    var prevListIndex = prevKeyMap.get(key); // In list, but not in prevList, it is added.\n\n    if (typeof prevListIndex === \"undefined\") {\n      added.push(listIndex);\n      ++addedCount;\n    } else {\n      maintained.push([prevListIndex, listIndex]);\n      removedCount = removedMap[listIndex] || 0;\n      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);\n      fixed.push(listIndex === prevListIndex);\n\n      if (prevListIndex !== listIndex) {\n        changed.push([prevListIndex, listIndex]);\n      }\n    }\n  }); // Sort by ascending order of 'to(list's index).\n\n  removed.reverse();\n  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed);\n}\n/**\n * A module that checks diff when values are added, removed, or changed in an array.\n * @ko 배열 또는 오브젝트에서 값이 추가되거나 삭제되거나 순서가 변경사항을 체크하는 모듈입니다.\n * @memberof eg\n */\n\n\nvar ListDiffer = /*#__PURE__*/function () {\n  /**\n   * @param - Initializing Data Array. <ko> 초기 설정할 데이터 배열.</ko>\n   * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>\n   * @example\n   * import ListDiffer from \"@egjs/list-differ\";\n   * // script => eg.ListDiffer\n   * const differ = new ListDiffer([0, 1, 2, 3, 4, 5], e => e);\n   * const result = differ.update([7, 8, 0, 4, 3, 6, 2, 1]);\n   * // List before update\n   * // [1, 2, 3, 4, 5]\n   * console.log(result.prevList);\n   * // Updated list\n   * // [4, 3, 6, 2, 1]\n   * console.log(result.list);\n   * // Index array of values added to `list`.\n   * // [0, 1, 5]\n   * console.log(result.added);\n   * // Index array of values removed in `prevList`.\n   * // [5]\n   * console.log(result.removed);\n   * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`.\n   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n   * console.log(result.changed);\n   * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n   * // [[4, 3], [3, 4], [2, 6]]\n   * console.log(result.pureChanged);\n   * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n   * // [[4, 1], [4, 2], [4, 3]]\n   * console.log(result.ordered);\n   * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved.\n   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n   * console.log(result.maintained);\n   */\n  function ListDiffer(list, findKeyCallback) {\n    if (list === void 0) {\n      list = [];\n    }\n\n    this.findKeyCallback = findKeyCallback;\n    this.list = [].slice.call(list);\n  }\n  /**\n   * Update list.\n   * @ko 리스트를 업데이트를 합니다.\n   * @param - List to update <ko> 업데이트할 리스트 </ko>\n   * @return - Returns the results of an update from `prevList` to `list`.<ko> `prevList`에서 `list`로 업데이트한 결과를 반환한다. </ko>\n   */\n\n\n  var __proto = ListDiffer.prototype;\n\n  __proto.update = function (list) {\n    var newData = [].slice.call(list);\n    var result = diff(this.list, newData, this.findKeyCallback);\n    this.list = newData;\n    return result;\n  };\n\n  return ListDiffer;\n}();\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\n\n\nexport default ListDiffer;\nexport { diff };","map":{"version":3,"sources":["../src/PolyMap.ts","../src/HashMap.ts","../src/consts.ts","../src/Link.ts","../src/Result.ts","../src/utils.ts","../src/ListDiffer.ts","../src/index.ts"],"names":["keys","values","prevIndex","index","SUPPORT_MAP","prevLink","nextLink","link","fromLinks","toLinks","changed","from","to","i","fixed","fromLink","toLink","fromIndex","toIndex","Object","ordered","orderChanged","pureChanged","_b","fromBefore","toBefore","diff","prevList","list","findKeyCallback","mapClass","callback","e","added","removed","maintained","prevKeys","prevKeyMap","keyMap","changedBeforeAdded","removedMap","addedCount","removedCount","listIndex","prevListIndex","newData","result"],"mappings":"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","sourcesContent":["/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nexport default class PolyMap<T> {\n  private keys: T[] = [];\n  private values: number[] = [];\n  public get(key: T): number {\n    return this.values[this.keys.indexOf(key)];\n  }\n  public set(key: T, value: number) {\n    const keys = this.keys;\n    const values = this.values;\n    const prevIndex = keys.indexOf(key);\n    const index = prevIndex === -1 ? keys.length : prevIndex;\n\n    keys[index] = key;\n    values[index] = value;\n  }\n}\n","/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nexport default class HashMap<T> {\n  private object = {};\n  public get(key: number | string): T {\n    return this.object[key];\n  }\n  public set(key: number | string, value: T) {\n    this.object[key] = value;\n  }\n};\n\n","/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nexport const SUPPORT_MAP = typeof Map === \"function\";\n","/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nexport default class Link {\n  prev?: Link;\n  next?: Link;\n\n  public connect(prevLink?: Link, nextLink?: Link) {\n    this.prev = prevLink;\n    this.next = nextLink;\n\n    prevLink && (prevLink.next = this);\n    nextLink && (nextLink.prev = this);\n  }\n  public disconnect() {\n    // In double linked list, diconnect the interconnected relationship.\n    const prevLink = this.prev;\n    const nextLink = this.next;\n    prevLink && (prevLink.next = nextLink);\n    nextLink && (nextLink.prev = prevLink);\n  }\n  public getIndex() {\n    let link: Link | undefined = this;\n    let index = -1;\n\n    while (link) {\n      link = link.prev;\n      ++index;\n    }\n    return index;\n  }\n}\n","/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nimport Link from \"./Link\";\n\nfunction orderChanged(changed: number[][], fixed: boolean[]) {\n  // It is roughly in the order of these examples.\n  // 4, 6, 0, 2, 1, 3, 5, 7\n  const fromLinks: Link[] = [];\n  // 0, 1, 2, 3, 4, 5, 6, 7\n  const toLinks: Link[] = [];\n\n  changed.forEach(([from, to]) => {\n    const link = new Link();\n\n    fromLinks[from] = link;\n    toLinks[to] = link;\n  });\n  // `fromLinks` are connected to each other by double linked list.\n  fromLinks.forEach((link, i) => {\n    link.connect(fromLinks[i - 1]);\n  });\n\n  return changed.filter((_, i) => !fixed[i]).map(([from, to], i) => {\n    if (from === to) {\n      return [0, 0];\n    }\n    const fromLink = fromLinks[from];\n    const toLink = toLinks[to - 1];\n    const fromIndex = fromLink.getIndex();\n\n    // Disconnect the link connected to `fromLink`.\n    fromLink.disconnect();\n\n    // Connect `fromLink` to the right of `toLink`.\n    if (!toLink) {\n      fromLink.connect(undefined, fromLinks[0]);\n    } else {\n      fromLink.connect(toLink, toLink.next);\n    }\n    const toIndex = fromLink.getIndex();\n    return [fromIndex, toIndex];\n  });\n}\n\nexport default class Result<T = any> {\n  public prevList: T[];\n  public list: T[];\n  public added: number[];\n  public removed: number[];\n  public changed: number[][];\n  public maintained: number[][];\n  private changedBeforeAdded: number[][];\n  private fixed: boolean[];\n\n  private cacheOrdered: number[][];\n  private cachePureChanged: number[][];\n  constructor(\n    prevList: T[],\n    list: T[],\n    added: number[],\n    removed: number[],\n    changed: number[][],\n    maintained: number[][],\n    changedBeforeAdded: number[][],\n    fixed: boolean[],\n  ) {\n    this.prevList = prevList;\n    this.list = list;\n    this.added = added;\n    this.removed = removed;\n    this.changed = changed;\n    this.maintained = maintained;\n    this.changedBeforeAdded = changedBeforeAdded;\n    this.fixed = fixed;\n  }\n  get ordered(): number[][] {\n    if (!this.cacheOrdered) {\n      this.caculateOrdered();\n    }\n    return this.cacheOrdered;\n  }\n  get pureChanged(): number[][] {\n    if (!this.cachePureChanged) {\n      this.caculateOrdered();\n    }\n    return this.cachePureChanged;\n  }\n  private caculateOrdered() {\n    const ordered = orderChanged(this.changedBeforeAdded, this.fixed);\n    const changed: number[][] = this.changed;\n    const pureChanged: number[][] = [];\n\n    this.cacheOrdered = ordered.filter(([from, to], i) => {\n      const [fromBefore, toBefore] = changed[i];\n\n      if (from !== to) {\n        pureChanged.push([fromBefore, toBefore]);\n        return true;\n      }\n    });\n    this.cachePureChanged = pureChanged;\n  }\n}\n","/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nimport { MapInteface, DiffResult } from \"./types\";\nimport PolyMap from \"./PolyMap\";\nimport HashMap from \"./HashMap\";\nimport { SUPPORT_MAP } from \"./consts\";\nimport Result from \"./Result\";\n\n/**\n *\n * @memberof eg.ListDiffer\n * @static\n * @function\n * @param - Previous List <ko> 이전 목록 </ko>\n * @param - List to Update <ko> 업데이트 할 목록 </ko>\n * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>\n * @return - Returns the diff between `prevList` and `list` <ko> `prevList`와 `list`의 다른 점을 반환한다.</ko>\n * @example\n * import { diff } from \"@egjs/list-differ\";\n * // script => eg.ListDiffer.diff\n * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1], e => e);\n * // List before update\n * // [1, 2, 3, 4, 5]\n * console.log(result.prevList);\n * // Updated list\n * // [4, 3, 6, 2, 1]\n * console.log(result.list);\n * // Index array of values added to `list`\n * // [0, 1, 5]\n * console.log(result.added);\n * // Index array of values removed in `prevList`\n * // [5]\n * console.log(result.removed);\n * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.changed);\n * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n * // [[4, 3], [3, 4], [2, 6]]\n * console.log(result.pureChanged);\n * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n * // [[4, 1], [4, 2], [4, 3]]\n * console.log(result.ordered);\n * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.maintained);\n */\nexport function diff<T>(\n  prevList: T[],\n  list: T[],\n  findKeyCallback?: (e: T, i: number, arr: T[]) => any\n): DiffResult<T> {\n  const mapClass: new () => MapInteface<any, number> = SUPPORT_MAP ? Map : (findKeyCallback ? HashMap : PolyMap);\n  const callback = findKeyCallback || ((e: T) => e);\n  const added: number[] = [];\n  const removed: number[] = [];\n  const maintained: number[][] = [];\n  const prevKeys = prevList.map(callback);\n  const keys = list.map(callback);\n  const prevKeyMap: MapInteface<any, number> = new mapClass();\n  const keyMap: MapInteface<any, number> = new mapClass();\n  const changedBeforeAdded: number[][] = [];\n  const fixed: boolean[] = [];\n  const removedMap: object = {};\n  let changed: number[][] = [];\n  let addedCount = 0;\n  let removedCount = 0;\n\n  // Add prevKeys and keys to the hashmap.\n  prevKeys.forEach((key, prevListIndex) => {\n    prevKeyMap.set(key, prevListIndex);\n  });\n  keys.forEach((key, listIndex) => {\n    keyMap.set(key, listIndex);\n  });\n\n  // Compare `prevKeys` and `keys` and add them to `removed` if they are not in `keys`.\n  prevKeys.forEach((key, prevListIndex) => {\n    const listIndex = keyMap.get(key);\n\n    // In prevList, but not in list, it is removed.\n    if (typeof listIndex === \"undefined\") {\n      ++removedCount;\n      removed.push(prevListIndex);\n    } else {\n      removedMap[listIndex] = removedCount;\n    }\n  });\n\n  // Compare `prevKeys` and `keys` and add them to `added` if they are not in `prevKeys`.\n  keys.forEach((key, listIndex) => {\n    const prevListIndex = prevKeyMap.get(key);\n\n    // In list, but not in prevList, it is added.\n    if (typeof prevListIndex === \"undefined\") {\n      added.push(listIndex);\n      ++addedCount;\n    } else {\n      maintained.push([prevListIndex, listIndex]);\n      removedCount = removedMap[listIndex] || 0;\n\n      changedBeforeAdded.push([\n        prevListIndex - removedCount,\n        listIndex - addedCount,\n      ]);\n      fixed.push(listIndex === prevListIndex);\n      if (prevListIndex !== listIndex) {\n        changed.push([prevListIndex, listIndex]);\n      }\n    }\n  });\n  // Sort by ascending order of 'to(list's index).\n  removed.reverse();\n\n  return new Result(\n    prevList,\n    list,\n    added,\n    removed,\n    changed,\n    maintained,\n    changedBeforeAdded,\n    fixed,\n  );\n}\n","/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nimport { DiffResult, ListFormat } from \"./types\";\nimport { diff } from \"./utils\";\n\n/**\n * A module that checks diff when values are added, removed, or changed in an array.\n * @ko 배열 또는 오브젝트에서 값이 추가되거나 삭제되거나 순서가 변경사항을 체크하는 모듈입니다.\n * @memberof eg\n */\nclass ListDiffer<T> {\n  private list: T[];\n  /**\n   * @param - Initializing Data Array. <ko> 초기 설정할 데이터 배열.</ko>\n   * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>\n   * @example\n   * import ListDiffer from \"@egjs/list-differ\";\n   * // script => eg.ListDiffer\n   * const differ = new ListDiffer([0, 1, 2, 3, 4, 5], e => e);\n   * const result = differ.update([7, 8, 0, 4, 3, 6, 2, 1]);\n   * // List before update\n   * // [1, 2, 3, 4, 5]\n   * console.log(result.prevList);\n   * // Updated list\n   * // [4, 3, 6, 2, 1]\n   * console.log(result.list);\n   * // Index array of values added to `list`.\n   * // [0, 1, 5]\n   * console.log(result.added);\n   * // Index array of values removed in `prevList`.\n   * // [5]\n   * console.log(result.removed);\n   * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`.\n   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n   * console.log(result.changed);\n   * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n   * // [[4, 3], [3, 4], [2, 6]]\n   * console.log(result.pureChanged);\n   * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n   * // [[4, 1], [4, 2], [4, 3]]\n   * console.log(result.ordered);\n   * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved.\n   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n   * console.log(result.maintained);\n   */\n  constructor(\n    list: ListFormat<T> = [],\n    private findKeyCallback?: (e: T, i: number, arr: T[]) => number | string,\n  ) {\n    this.list = [].slice.call(list);\n  }\n  /**\n   * Update list.\n   * @ko 리스트를 업데이트를 합니다.\n   * @param - List to update <ko> 업데이트할 리스트 </ko>\n   * @return - Returns the results of an update from `prevList` to `list`.<ko> `prevList`에서 `list`로 업데이트한 결과를 반환한다. </ko>\n   */\n  public update(list: ListFormat<T>): DiffResult<T> {\n    const newData: T[] = [].slice.call(list);\n    const result = diff<T>(this.list, newData, this.findKeyCallback);\n\n    this.list = newData;\n    return result;\n  }\n}\n\nexport default ListDiffer;\n","/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nimport ListDiffer from \"./ListDiffer\";\nexport default ListDiffer;\nexport { diff } from \"./utils\";\nexport * from \"./types\";\n"]},"metadata":{},"sourceType":"module"}