{"ast":null,"code":"/*\nCopyright (c) 2019 Daybrush\nname: framework-utils\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/framework-utils.git\nversion: 0.3.4\n*/\nfunction prefixNames(prefix) {\n  var classNames = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    classNames[_i - 1] = arguments[_i];\n  }\n\n  return classNames.map(function (className) {\n    return className.split(\" \").map(function (name) {\n      return name ? \"\" + prefix + name : \"\";\n    }).join(\" \");\n  }).join(\" \");\n}\n\nfunction prefixCSS(prefix, css) {\n  return css.replace(/([^}{]*){/mg, function (_, selector) {\n    return selector.replace(/\\.([^{,\\s\\d.]+)/g, \".\" + prefix + \"$1\") + \"{\";\n  });\n}\n/* react */\n\n\nfunction ref(target, name) {\n  return function (e) {\n    e && (target[name] = e);\n  };\n}\n\nfunction refs(target, name, i) {\n  return function (e) {\n    e && (target[name][i] = e);\n  };\n}\n/* Class Decorator */\n\n\nfunction Properties(properties, action) {\n  return function (component) {\n    var prototype = component.prototype;\n    properties.forEach(function (property) {\n      action(prototype, property);\n    });\n  };\n}\n/* Property Decorator */\n\n\nfunction withMethods(methods, duplicate) {\n  if (duplicate === void 0) {\n    duplicate = {};\n  }\n\n  return function (prototype, propertyName) {\n    methods.forEach(function (name) {\n      var methodName = duplicate[name] || name;\n\n      if (prototype[methodName]) {\n        return;\n      }\n\n      prototype[methodName] = function () {\n        var _a;\n\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var result = (_a = this[propertyName])[name].apply(_a, args);\n\n        if (result === this[propertyName]) {\n          return this;\n        } else {\n          return result;\n        }\n      };\n    });\n  };\n}\n\nexport { Properties, prefixCSS, prefixNames, ref, refs, withMethods };","map":{"version":3,"sources":["../src/index.ts"],"names":["prefixNames","prefix","classNames","name","prefixCSS","css","selector","ref","target","e","refs","i","Properties","properties","action","prototype","component","withMethods","methods","duplicate","methodName","args","result"],"mappings":";;;;;;;;SAAgBA,W,CAAYC,M,EAAAA;mBAAgBC,E;;OAAAA,IAAAA,EAAAA,GAAAA,C,EAAAA,EAAAA,GAAAA,SAAAA,CAAAA,M,EAAAA,EAAAA,E,EAAAA;AAAAA,IAAAA,UAAAA,CAAAA,EAAAA,GAAAA,CAAAA,CAAAA,GAAAA,SAAAA,CAAAA,EAAAA,CAAAA;;;SACjC,UAAU,CAAV,GAAA,CACH,UAAA,SAAA,EAAA;WAAa,SAAS,CAAT,KAAA,CAAA,GAAA,EAAA,GAAA,CAAyB,UAAA,IAAA,EAAA;aAAQC,IAAI,GAAG,KAAA,MAAA,GAAH,IAAA,GAAJA,E;AAAjC,KAAA,EAAA,IAAA,CAAA,GAAA,C;AADV,GAAA,EAAA,IAAA,CAAP,GAAO,C;;;AAKX,SAAgBC,SAAhB,CAA0BH,MAA1B,EAA0CI,GAA1C,EAA0CA;SAC/B,GAAG,CAAH,OAAA,CAAA,aAAA,EAA2B,UAAA,CAAA,EAAA,QAAA,EAAA;WACpBC,QAAQ,CAARA,OAAAA,CAAAA,kBAAAA,EAAqC,MAAA,MAAA,GAArCA,IAAAA,IAAV,G;AADJ,GAAO,C;;;;;AAMX,SAAgBC,GAAhB,CAAoBC,MAApB,EAAiCL,IAAjC,EAAiCA;SACtB,UAAA,CAAA,EAAA;AACHM,IAAAA,CAAC,KAAKD,MAAM,CAANA,IAAM,CAANA,GAANC,CAAC,CAADA;AADJ,G;;;AAIJ,SAAgBC,IAAhB,CAAqBF,MAArB,EAAkCL,IAAlC,EAAgDQ,CAAhD,EAAgDA;SACrC,UAAA,CAAA,EAAA;AACHF,IAAAA,CAAC,KAAKD,MAAM,CAANA,IAAM,CAANA,CAAAA,CAAAA,IAANC,CAAC,CAADA;AADJ,G;;;;;AAMJ,SAAgBG,UAAhB,CAA2BC,UAA3B,EAA8CC,MAA9C,EAA8CA;SACnC,UAAA,SAAA,EAAA;QACGC,SAAS,GAAGC,SAAS,CAA3B,S;AAEAH,IAAAA,UAAU,CAAVA,OAAAA,CAAmB,UAAA,QAAA,EAAA;AACfC,MAAAA,MAAM,CAAA,SAAA,EAANA,QAAM,CAANA;AADJD,KAAAA;AAHJ,G;;;;;AAUJ,SAAgBI,WAAhB,CAA4BC,OAA5B,EAA+CC,SAA/C,EAA+CA;yBAAAA,C,EAAAA;AAAAA,IAAAA,SAAAA,GAAAA,EAAAA;;;SACpC,UAAA,SAAA,EAAA,YAAA,EAAA;AACHD,IAAAA,OAAO,CAAPA,OAAAA,CAAgB,UAAA,IAAA,EAAA;UACNE,UAAU,GAAGD,SAAS,CAATA,IAAS,CAATA,IAAnB,I;;UAEIJ,SAAS,CAAb,UAAa,C,EAAc;;;;AAG3BA,MAAAA,SAAS,CAATA,UAAS,CAATA,GAAwB,YAAA;;;mBAASM,E;;aAAAA,IAAAA,EAAAA,GAAAA,C,EAAAA,EAAAA,GAAAA,SAAAA,CAAAA,M,EAAAA,EAAAA,E,EAAAA;AAAAA,UAAAA,IAAAA,CAAAA,EAAAA,CAAAA,GAAAA,SAAAA,CAAAA,EAAAA,CAAAA;;;YACvBC,MAAM,GAAG,CAAA,EAAA,GAAA,KAAA,YAAA,CAAA,EAAA,IAAA,EAAA,KAAA,CAAA,EAAA,EAAf,IAAe,C;;YAEXA,MAAM,KAAK,KAAf,YAAe,C,EAAoB;iBAC/B,I;AADJ,S,MAEO;iBACH,M;;AANRP,OAAAA;AANJG,KAAAA;AADJ,G","sourcesContent":["export function prefixNames(prefix: string, ...classNames: string[]) {\n    return classNames.map(\n        className => className.split(\" \").map(name => name ? `${prefix}${name}` : \"\").join(\" \"),\n    ).join(\" \");\n}\n\nexport function prefixCSS(prefix: string, css: string) {\n    return css.replace(/([^}{]*){/mg, (_, selector) => {\n        return `${selector.replace(/\\.([^{,\\s\\d.]+)/g, `.${prefix}$1`)}{`;\n    });\n}\n\n/* react */\nexport function ref(target: any, name: string) {\n    return (e: any) => {\n        e && (target[name] = e);\n    };\n}\nexport function refs(target: any, name: string, i: number) {\n    return (e: any) => {\n        e && (target[name][i] = e);\n    };\n}\n\n/* Class Decorator */\nexport function Properties(properties: any[], action: (prototype: any, property: string) => any) {\n    return (component: any) => {\n        const prototype = component.prototype;\n\n        properties.forEach(property => {\n            action(prototype, property);\n        });\n    };\n}\n\n/* Property Decorator */\nexport function withMethods(methods: string[], duplicate: { [name: string]: string } = {}) {\n    return (prototype: any, propertyName: string) => {\n        methods.forEach(name => {\n            const methodName = duplicate[name] || name;\n\n            if (prototype[methodName]) {\n                return;\n            }\n            prototype[methodName] = function(...args) {\n                const result = this[propertyName][name](...args);\n\n                if (result === this[propertyName]) {\n                    return this;\n                } else {\n                    return result;\n                }\n            };\n        });\n    };\n}\n\nexport type ParametersType<T, R> = T extends (...params: infer U) => any ? (...params: U) => R : never;\nexport type ExcludeInterface<T, U> = {\n    [key in (Exclude<keyof T, keyof U>)]: T[key];\n};\nexport type Entries<T extends { [key: string]: any }, U = keyof T> = U extends string ? [U, T[U]] : never;\nexport type ReverseKey<T extends string, U extends { [key: string]: any }, E = Entries<U>>\n    = E extends [infer K, T] ? K : never;\n\nexport type MethodInterface<T, U extends T, R extends any, Duplicate extends { [key: string]: any } = {}> = {\n    [key in keyof ExcludeInterface<T, Duplicate>]:\n        T[key] extends (...params: any[]) => U ? ParametersType<T[key], R> : T[key];\n} & {\n    [key in Duplicate[keyof Duplicate]]:\n        T[ReverseKey<key, Duplicate> & keyof T] extends (...params: any[]) => U\n            ? ParametersType<T[ReverseKey<key, Duplicate> & keyof T], R>\n            : T[ReverseKey<key, Duplicate> & keyof T];\n};\n"]},"metadata":{},"sourceType":"module"}