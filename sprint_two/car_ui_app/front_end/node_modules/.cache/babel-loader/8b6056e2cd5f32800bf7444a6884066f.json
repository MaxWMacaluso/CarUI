{"ast":null,"code":"/*\nCopyright (c) 2019 Daybrush\nname: gesto\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/gesture.git\nversion: 1.2.1\n*/\nimport EventEmitter from '@scena/event-emitter';\nimport { removeEvent, now, addEvent } from '@daybrush/utils';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction getRad(pos1, pos2) {\n  var distX = pos2[0] - pos1[0];\n  var distY = pos2[1] - pos1[1];\n  var rad = Math.atan2(distY, distX);\n  return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n\nfunction getRotatiion(touches) {\n  return getRad([touches[0].clientX, touches[0].clientY], [touches[1].clientX, touches[1].clientY]) / Math.PI * 180;\n}\n\nfunction isMultiTouch(e) {\n  return e.touches && e.touches.length >= 2;\n}\n\nfunction getEventClients(e) {\n  if (e.touches) {\n    return getClients(e.touches);\n  } else {\n    return [getClient(e)];\n  }\n}\n\nfunction getPosition(clients, prevClients, startClients) {\n  var length = startClients.length;\n\n  var _a = getAverageClient(clients, length),\n      clientX = _a.clientX,\n      clientY = _a.clientY,\n      originalClientX = _a.originalClientX,\n      originalClientY = _a.originalClientY;\n\n  var _b = getAverageClient(prevClients, length),\n      prevX = _b.clientX,\n      prevY = _b.clientY;\n\n  var _c = getAverageClient(startClients, length),\n      startX = _c.clientX,\n      startY = _c.clientY;\n\n  var deltaX = clientX - prevX;\n  var deltaY = clientY - prevY;\n  var distX = clientX - startX;\n  var distY = clientY - startY;\n  return {\n    clientX: originalClientX,\n    clientY: originalClientY,\n    deltaX: deltaX,\n    deltaY: deltaY,\n    distX: distX,\n    distY: distY\n  };\n}\n\nfunction getDist(clients) {\n  return Math.sqrt(Math.pow(clients[0].clientX - clients[1].clientX, 2) + Math.pow(clients[0].clientY - clients[1].clientY, 2));\n}\n\nfunction getClients(touches) {\n  var length = Math.min(touches.length, 2);\n  var clients = [];\n\n  for (var i = 0; i < length; ++i) {\n    clients.push(getClient(touches[i]));\n  }\n\n  return clients;\n}\n\nfunction getClient(e) {\n  return {\n    clientX: e.clientX,\n    clientY: e.clientY\n  };\n}\n\nfunction getAverageClient(clients, length) {\n  if (length === void 0) {\n    length = clients.length;\n  }\n\n  var sumClient = {\n    clientX: 0,\n    clientY: 0,\n    originalClientX: 0,\n    originalClientY: 0\n  };\n\n  for (var i = 0; i < length; ++i) {\n    var client = clients[i];\n    sumClient.originalClientX += \"originalClientX\" in client ? client.originalClientX : client.clientX;\n    sumClient.originalClientY += \"originalClientY\" in client ? client.originalClientY : client.clientY;\n    sumClient.clientX += client.clientX;\n    sumClient.clientY += client.clientY;\n  }\n\n  if (!length) {\n    return sumClient;\n  }\n\n  return {\n    clientX: sumClient.clientX / length,\n    clientY: sumClient.clientY / length,\n    originalClientX: sumClient.originalClientX / length,\n    originalClientY: sumClient.originalClientY / length\n  };\n}\n\nvar ClientStore = /*#__PURE__*/function () {\n  function ClientStore(clients) {\n    this.prevClients = [];\n    this.startClients = [];\n    this.movement = 0;\n    this.length = 0;\n    this.startClients = clients;\n    this.prevClients = clients;\n    this.length = clients.length;\n  }\n\n  var __proto = ClientStore.prototype;\n\n  __proto.addClients = function (clients) {\n    if (clients === void 0) {\n      clients = this.prevClients;\n    }\n\n    var position = this.getPosition(clients);\n    var deltaX = position.deltaX,\n        deltaY = position.deltaY;\n    this.movement += Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    this.prevClients = clients;\n    return position;\n  };\n\n  __proto.getAngle = function (clients) {\n    if (clients === void 0) {\n      clients = this.prevClients;\n    }\n\n    return getRotatiion(clients);\n  };\n\n  __proto.getRotation = function (clients) {\n    if (clients === void 0) {\n      clients = this.prevClients;\n    }\n\n    return getRotatiion(clients) - getRotatiion(this.startClients);\n  };\n\n  __proto.getPosition = function (clients) {\n    return getPosition(clients || this.prevClients, this.prevClients, this.startClients);\n  };\n\n  __proto.getPositions = function (clients) {\n    if (clients === void 0) {\n      clients = this.prevClients;\n    }\n\n    var prevClients = this.prevClients;\n    return this.startClients.map(function (startClient, i) {\n      return getPosition([clients[i]], [prevClients[i]], [startClient]);\n    });\n  };\n\n  __proto.getMovement = function (clients) {\n    var movement = this.movement;\n\n    if (!clients) {\n      return movement;\n    }\n\n    var currentClient = getAverageClient(clients, this.length);\n    var prevClient = getAverageClient(this.prevClients, this.length);\n    var deltaX = currentClient.clientX - prevClient.clientX;\n    var deltaY = currentClient.clientY - prevClient.clientY;\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY) + movement;\n  };\n\n  __proto.getDistance = function (clients) {\n    if (clients === void 0) {\n      clients = this.prevClients;\n    }\n\n    return getDist(clients);\n  };\n\n  __proto.getScale = function (clients) {\n    if (clients === void 0) {\n      clients = this.prevClients;\n    }\n\n    return getDist(clients) / getDist(this.startClients);\n  };\n\n  __proto.move = function (deltaX, deltaY) {\n    this.startClients.forEach(function (client) {\n      client.clientX -= deltaX;\n      client.clientY -= deltaY;\n    });\n    this.prevClients.forEach(function (client) {\n      client.clientX -= deltaX;\n      client.clientY -= deltaY;\n    });\n  };\n\n  return ClientStore;\n}();\n\nvar INPUT_TAGNAMES = [\"textarea\", \"input\"];\n/**\n * You can set up drag, pinch events in any browser.\n */\n\nvar Gesto = /*#__PURE__*/function (_super) {\n  __extends(Gesto, _super);\n  /**\n   *\n   */\n\n\n  function Gesto(targets, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.options = {};\n    _this.flag = false;\n    _this.pinchFlag = false;\n    _this.datas = {};\n    _this.isDrag = false;\n    _this.isPinch = false;\n    _this.isMouse = false;\n    _this.isTouch = false;\n    _this.clientStores = [];\n    _this.targets = [];\n    _this.prevTime = 0;\n    _this.isDouble = false;\n\n    _this.onDragStart = function (e, isTrusted) {\n      if (isTrusted === void 0) {\n        isTrusted = true;\n      }\n\n      if (!_this.flag && e.cancelable === false) {\n        return;\n      }\n\n      var _a = _this.options,\n          container = _a.container,\n          pinchOutside = _a.pinchOutside,\n          preventRightClick = _a.preventRightClick,\n          preventDefault = _a.preventDefault,\n          checkInput = _a.checkInput;\n      var isTouch = _this.isTouch;\n      var isDragStart = !_this.flag;\n\n      if (isDragStart) {\n        var activeElement = document.activeElement;\n        var target = e.target;\n        var tagName = target.tagName.toLowerCase();\n        var hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;\n        var hasContentEditable = target.isContentEditable;\n\n        if (hasInput || hasContentEditable) {\n          if (checkInput || activeElement === target) {\n            // force false or already focused.\n            return false;\n          }\n\n          if (activeElement && hasContentEditable && activeElement.isContentEditable && activeElement.contains(target)) {\n            return false;\n          }\n        } else if ((preventDefault || e.type === \"touchstart\") && activeElement) {\n          var activeTagName = activeElement.tagName;\n\n          if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {\n            activeElement.blur();\n          }\n        }\n\n        _this.clientStores = [new ClientStore(getEventClients(e))];\n        _this.flag = true;\n        _this.isDrag = false;\n        _this.datas = {};\n\n        if (preventRightClick && (e.which === 3 || e.button === 2)) {\n          _this.initDrag();\n\n          return false;\n        }\n\n        var result = _this.emit(\"dragStart\", __assign({\n          datas: _this.datas,\n          inputEvent: e,\n          isTrusted: isTrusted\n        }, _this.getCurrentStore().getPosition()));\n\n        if (result === false) {\n          _this.initDrag();\n        }\n\n        _this.isDouble = now() - _this.prevTime < 200;\n        _this.flag && preventDefault && e.preventDefault();\n      }\n\n      if (!_this.flag) {\n        return false;\n      }\n\n      var timer = 0;\n\n      if (isDragStart && isTouch && pinchOutside) {\n        timer = setTimeout(function () {\n          addEvent(container, \"touchstart\", _this.onDragStart, {\n            passive: false\n          });\n        });\n      }\n\n      if (!isDragStart && isTouch && pinchOutside) {\n        removeEvent(container, \"touchstart\", _this.onDragStart);\n      }\n\n      if (_this.flag && isMultiTouch(e)) {\n        clearTimeout(timer);\n\n        if (isDragStart && e.touches.length !== e.changedTouches.length) {\n          return;\n        }\n\n        if (!_this.pinchFlag) {\n          _this.onPinchStart(e);\n        }\n      }\n    };\n\n    _this.onDrag = function (e, isScroll) {\n      if (!_this.flag) {\n        return;\n      }\n\n      var clients = getEventClients(e);\n\n      var result = _this.moveClients(clients, e, false);\n\n      if (_this.pinchFlag || result.deltaX || result.deltaY) {\n        _this.emit(\"drag\", __assign({}, result, {\n          isScroll: !!isScroll,\n          inputEvent: e\n        }));\n      }\n\n      if (_this.pinchFlag) {\n        _this.onPinch(e, clients);\n      }\n\n      _this.getCurrentStore().addClients(clients);\n    };\n\n    _this.onDragEnd = function (e) {\n      if (!_this.flag) {\n        return;\n      }\n\n      var _a = _this.options,\n          pinchOutside = _a.pinchOutside,\n          container = _a.container;\n\n      if (_this.isTouch && pinchOutside) {\n        removeEvent(container, \"touchstart\", _this.onDragStart);\n      }\n\n      _this.flag = false;\n\n      var position = _this.getCurrentStore().getPosition();\n\n      var currentTime = now();\n      var isDouble = !_this.isDrag && _this.isDouble;\n      _this.prevTime = _this.isDrag || isDouble ? 0 : currentTime;\n\n      _this.emit(\"dragEnd\", __assign({\n        datas: _this.datas,\n        isDouble: isDouble,\n        isDrag: _this.isDrag,\n        inputEvent: e\n      }, position));\n\n      if (_this.pinchFlag) {\n        _this.onPinchEnd(e);\n      }\n\n      _this.clientStores = [];\n    };\n\n    _this.onBlur = function () {\n      _this.onDragEnd();\n    };\n\n    var elements = [].concat(targets);\n    _this.options = __assign({\n      checkInput: false,\n      container: elements.length > 1 ? window : elements[0],\n      preventRightClick: true,\n      preventDefault: true,\n      checkWindowBlur: false,\n      pinchThreshold: 0,\n      events: [\"touch\", \"mouse\"]\n    }, options);\n    var _a = _this.options,\n        container = _a.container,\n        events = _a.events,\n        checkWindowBlur = _a.checkWindowBlur;\n    _this.isTouch = events.indexOf(\"touch\") > -1;\n    _this.isMouse = events.indexOf(\"mouse\") > -1;\n    _this.targets = elements;\n\n    if (_this.isMouse) {\n      elements.forEach(function (el) {\n        addEvent(el, \"mousedown\", _this.onDragStart);\n      });\n      addEvent(container, \"mousemove\", _this.onDrag);\n      addEvent(container, \"mouseup\", _this.onDragEnd);\n      addEvent(container, \"contextmenu\", _this.onDragEnd);\n    }\n\n    if (checkWindowBlur) {\n      addEvent(window, \"blur\", _this.onBlur);\n    }\n\n    if (_this.isTouch) {\n      var passive_1 = {\n        passive: false\n      };\n      elements.forEach(function (el) {\n        addEvent(el, \"touchstart\", _this.onDragStart, passive_1);\n      });\n      addEvent(container, \"touchmove\", _this.onDrag, passive_1);\n      addEvent(container, \"touchend\", _this.onDragEnd, passive_1);\n      addEvent(container, \"touchcancel\", _this.onDragEnd, passive_1);\n    }\n\n    return _this;\n  }\n  /**\n   * The total moved distance\n   */\n\n\n  var __proto = Gesto.prototype;\n\n  __proto.getMovement = function (clients) {\n    return this.getCurrentStore().getMovement(clients) + this.clientStores.slice(1).reduce(function (prev, cur) {\n      return prev + cur.movement;\n    }, 0);\n  };\n  /**\n   * Whether to drag\n   */\n\n\n  __proto.isDragging = function () {\n    return this.isDrag;\n  };\n  /**\n   * Whether to start drag\n   */\n\n\n  __proto.isFlag = function () {\n    return this.flag;\n  };\n  /**\n   * Whether to start pinch\n   */\n\n\n  __proto.isPinchFlag = function () {\n    return this.pinchFlag;\n  };\n  /**\n   * Whether to pinch\n   */\n\n\n  __proto.isPinching = function () {\n    return this.isPinch;\n  };\n  /**\n   * If a scroll event occurs, it is corrected by the scroll distance.\n   */\n\n\n  __proto.scrollBy = function (deltaX, deltaY, e, isCallDrag) {\n    if (isCallDrag === void 0) {\n      isCallDrag = true;\n    }\n\n    if (!this.flag) {\n      return;\n    }\n\n    this.clientStores[0].move(deltaX, deltaY);\n    isCallDrag && this.onDrag(e, true);\n  };\n  /**\n   * Create a virtual drag event.\n   */\n\n\n  __proto.move = function (_a, inputEvent) {\n    var deltaX = _a[0],\n        deltaY = _a[1];\n    var store = this.getCurrentStore();\n    var nextClients = store.prevClients;\n    return this.moveClients(nextClients.map(function (_a) {\n      var clientX = _a.clientX,\n          clientY = _a.clientY;\n      return {\n        clientX: clientX + deltaX,\n        clientY: clientY + deltaY,\n        originalClientX: clientX,\n        originalClientY: clientY\n      };\n    }), inputEvent, true);\n  };\n  /**\n   * The dragStart event is triggered by an external event.\n   */\n\n\n  __proto.triggerDragStart = function (e) {\n    this.onDragStart(e, false);\n  };\n  /**\n   * Set the event data while dragging.\n   */\n\n\n  __proto.setEventDatas = function (datas) {\n    var currentDatas = this.datas;\n\n    for (var name in datas) {\n      currentDatas[name] = datas[name];\n    }\n\n    return this;\n  };\n  /**\n   * Set the event data while dragging.\n   */\n\n\n  __proto.getEventDatas = function () {\n    return this.datas;\n  };\n  /**\n   * Unset Gesto\n   */\n\n\n  __proto.unset = function () {\n    var _this = this;\n\n    var targets = this.targets;\n    var container = this.options.container;\n    this.off();\n    removeEvent(window, \"blur\", this.onBlur);\n\n    if (this.isMouse) {\n      targets.forEach(function (target) {\n        removeEvent(target, \"mousedown\", _this.onDragStart);\n      });\n      removeEvent(container, \"mousemove\", this.onDrag);\n      removeEvent(container, \"mouseup\", this.onDragEnd);\n      removeEvent(container, \"contextmenu\", this.onDragEnd);\n    }\n\n    if (this.isTouch) {\n      targets.forEach(function (target) {\n        removeEvent(target, \"touchstart\", _this.onDragStart);\n      });\n      removeEvent(container, \"touchstart\", this.onDragStart);\n      removeEvent(container, \"touchmove\", this.onDrag);\n      removeEvent(container, \"touchend\", this.onDragEnd);\n      removeEvent(container, \"touchcancel\", this.onDragEnd);\n    }\n  };\n\n  __proto.onPinchStart = function (e) {\n    var pinchThreshold = this.options.pinchThreshold;\n\n    if (this.isDrag && this.getMovement() > pinchThreshold) {\n      return;\n    }\n\n    var store = new ClientStore(getEventClients(e));\n    this.pinchFlag = true;\n    this.clientStores.splice(0, 0, store);\n    var result = this.emit(\"pinchStart\", __assign({\n      datas: this.datas,\n      angle: store.getAngle(),\n      touches: this.getCurrentStore().getPositions()\n    }, store.getPosition(), {\n      inputEvent: e\n    }));\n\n    if (result === false) {\n      this.pinchFlag = false;\n    }\n  };\n\n  __proto.onPinch = function (e, clients) {\n    if (!this.flag || !this.pinchFlag || clients.length < 2) {\n      return;\n    }\n\n    var store = this.getCurrentStore();\n    this.isPinch = true;\n    this.emit(\"pinch\", __assign({\n      datas: this.datas,\n      movement: this.getMovement(clients),\n      angle: store.getAngle(clients),\n      rotation: store.getRotation(clients),\n      touches: store.getPositions(clients),\n      scale: store.getScale(clients),\n      distance: store.getDistance(clients)\n    }, store.getPosition(clients), {\n      inputEvent: e\n    }));\n  };\n\n  __proto.onPinchEnd = function (e) {\n    if (!this.pinchFlag) {\n      return;\n    }\n\n    var isPinch = this.isPinch;\n    this.isPinch = false;\n    this.pinchFlag = false;\n    var store = this.getCurrentStore();\n    this.emit(\"pinchEnd\", __assign({\n      datas: this.datas,\n      isPinch: isPinch,\n      touches: store.getPositions()\n    }, store.getPosition(), {\n      inputEvent: e\n    }));\n    this.isPinch = false;\n    this.pinchFlag = false;\n  };\n\n  __proto.initDrag = function () {\n    this.clientStores = [];\n    this.pinchFlag = false;\n    this.flag = false;\n  };\n\n  __proto.getCurrentStore = function () {\n    return this.clientStores[0];\n  };\n\n  __proto.moveClients = function (clients, inputEvent, isAdd) {\n    var store = this.getCurrentStore();\n    var position = store[isAdd ? \"addClients\" : \"getPosition\"](clients);\n    this.isDrag = true;\n    return __assign({\n      datas: this.datas\n    }, position, {\n      movement: this.getMovement(clients),\n      isDrag: this.isDrag,\n      isPinch: this.isPinch,\n      isScroll: false,\n      inputEvent: inputEvent\n    });\n  };\n\n  return Gesto;\n}(EventEmitter);\n\nexport default Gesto;","map":{"version":3,"sources":["../src/utils.ts","../src/ClientStore.ts","../src/Gesto.ts"],"names":["getRad","pos1","pos2","distX","distY","rad","Math","getRotatiion","touches","isMultiTouch","e","getEventClients","getClients","getClient","getPosition","clients","prevClients","startClients","length","_a","clientX","clientY","originalClientX","originalClientY","_b","prevX","prevY","_c","startX","startY","deltaX","deltaY","getDist","i","getAverageClient","sumClient","client","position","movement","currentClient","prevClient","INPUT_TAGNAMES","tslib_1","_this","options","_super","elements","checkInput","container","preventRightClick","preventDefault","checkWindowBlur","pinchThreshold","events","addEvent","passive_1","passive","prev","cur","isCallDrag","store","nextClients","currentDatas","datas","targets","removeEvent","isTrusted","pinchOutside","isTouch","isDragStart","activeElement","document","target","tagName","hasInput","hasContentEditable","activeTagName","result","inputEvent","now","timer","setTimeout","clearTimeout","isScroll","currentTime","isDouble","isDrag","angle","rotation","scale","distance","isPinch","isAdd"],"mappings":"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","sourcesContent":["import { Client, Position } from \"./types\";\nimport { IArrayFormat } from \"@daybrush/utils\";\n\nexport function getRad(pos1: number[], pos2: number[]) {\n    const distX = pos2[0] - pos1[0];\n    const distY = pos2[1] - pos1[1];\n    const rad = Math.atan2(distY, distX);\n\n    return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n\nexport function getRotatiion(touches: Client[]) {\n    return getRad([\n        touches[0].clientX,\n        touches[0].clientY,\n    ], [\n        touches[1].clientX,\n        touches[1].clientY,\n    ]) / Math.PI * 180;\n}\n\nexport function isMultiTouch(e: any): e is TouchEvent {\n    return e.touches && e.touches.length >= 2;\n}\nexport function getEventClients(e: any): Client[] {\n    if (e.touches) {\n        return getClients(e.touches);\n    } else {\n        return [getClient(e)];\n    }\n}\nexport function getPosition(clients: Client[], prevClients: Client[], startClients: Client[]): Position {\n    const length = startClients.length;\n    const {\n        clientX, clientY,\n        originalClientX, originalClientY,\n    } = getAverageClient(clients, length);\n    const {\n        clientX: prevX,\n        clientY: prevY,\n    } = getAverageClient(prevClients, length);\n\n    const {\n        clientX: startX,\n        clientY: startY,\n    } = getAverageClient(startClients, length);\n    const deltaX = clientX - prevX;\n    const deltaY = clientY - prevY;\n    const distX = clientX - startX;\n    const distY = clientY - startY;\n\n    return {\n        clientX: originalClientX!,\n        clientY: originalClientY!,\n        deltaX,\n        deltaY,\n        distX,\n        distY,\n    };\n}\nexport function getDist(clients: Client[]) {\n    return Math.sqrt(\n        Math.pow(clients[0].clientX - clients[1].clientX, 2)\n        + Math.pow(clients[0].clientY - clients[1].clientY, 2),\n    );\n}\nexport function getClients(touches: IArrayFormat<Touch>) {\n    const length = Math.min(touches.length, 2);\n    const clients = [];\n\n    for (let i = 0; i < length; ++i) {\n        clients.push(getClient(touches[i]));\n    }\n    return clients;\n}\nexport function getClient(e: MouseEvent | Touch): Client {\n    return {\n        clientX: e.clientX,\n        clientY: e.clientY,\n    };\n}\nexport function getAverageClient(clients: Client[], length = clients.length): Required<Client> {\n    const sumClient: Required<Client> = {\n        clientX: 0,\n        clientY: 0,\n        originalClientX: 0,\n        originalClientY: 0,\n    };\n    for (let i = 0; i < length; ++i) {\n        const client = clients[i];\n\n        sumClient.originalClientX += \"originalClientX\" in client ? client.originalClientX! : client.clientX;\n        sumClient.originalClientY += \"originalClientY\" in client ? client.originalClientY! : client.clientY;\n        sumClient.clientX += client.clientX;\n        sumClient.clientY += client.clientY;\n    }\n    if (!length) {\n        return sumClient;\n    }\n    return {\n        clientX: sumClient.clientX / length,\n        clientY: sumClient.clientY / length,\n        originalClientX: sumClient.originalClientX / length,\n        originalClientY: sumClient.originalClientY / length,\n    };\n}\nexport function plueClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX + client2.clientX),\n        clientY: (client1.clientY + client2.clientY),\n    };\n}\n\nexport function minusClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX - client2.clientX),\n        clientY: (client1.clientY - client2.clientY),\n    };\n}\n","import { Client } from \"./types\";\nimport { getPosition, getDist, getRotatiion, getAverageClient } from \"./utils\";\n\nexport class ClientStore {\n    public prevClients: Client[] = [];\n    public startClients: Client[] = [];\n    public movement = 0;\n    public length  = 0;\n    constructor(clients: Client[]) {\n        this.startClients = clients;\n        this.prevClients = clients;\n        this.length = clients.length;\n    }\n    public addClients(clients: Client[] = this.prevClients) {\n        const position = this.getPosition(clients);\n        const { deltaX, deltaY } = position;\n\n        this.movement += Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        this.prevClients = clients;\n\n        return position;\n    }\n    public getAngle(clients: Client[] = this.prevClients) {\n        return getRotatiion(clients);\n    }\n    public getRotation(clients: Client[] = this.prevClients) {\n        return getRotatiion(clients) - getRotatiion(this.startClients);\n    }\n    public getPosition(clients?: Client[]) {\n        return getPosition(clients || this.prevClients, this.prevClients, this.startClients);\n    }\n    public getPositions(clients: Client[] = this.prevClients) {\n        const prevClients = this.prevClients;\n\n        return this.startClients.map((startClient, i) => getPosition([clients[i]], [prevClients[i]], [startClient]));\n    }\n    public getMovement(clients?: Client[]) {\n        const movement = this.movement;\n\n        if (!clients) {\n            return movement;\n        }\n        const currentClient = getAverageClient(clients, this.length);\n        const prevClient = getAverageClient(this.prevClients, this.length);\n        const deltaX = currentClient.clientX - prevClient.clientX;\n        const deltaY = currentClient.clientY - prevClient.clientY;\n\n        return Math.sqrt(deltaX * deltaX + deltaY * deltaY) + movement;\n    }\n    public getDistance(clients = this.prevClients) {\n        return getDist(clients);\n    }\n    public getScale(clients = this.prevClients) {\n        return getDist(clients) / getDist(this.startClients);\n    }\n    public move(deltaX: number, deltaY: number) {\n        this.startClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n        this.prevClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n    }\n}\n","import { Client, OnDrag, GestoOptions, GestoEvents } from \"./types\";\nimport {\n    getEventClients, isMultiTouch,\n} from \"./utils\";\nimport EventEmitter, { TargetParam } from \"@scena/event-emitter\";\nimport { addEvent, removeEvent, now, IObject } from \"@daybrush/utils\";\nimport { ClientStore } from \"./ClientStore\";\n\nconst INPUT_TAGNAMES = [\"textarea\", \"input\"];\n/**\n * You can set up drag, pinch events in any browser.\n */\nclass Gesto extends EventEmitter<GestoEvents> {\n    public options: GestoOptions = {};\n    private flag = false;\n    private pinchFlag = false;\n    private datas: IObject<any> = {};\n    private isDrag = false;\n    private isPinch = false;\n    private isMouse = false;\n    private isTouch = false;\n    private clientStores: ClientStore[] = [];\n    private targets: Array<Element | Window> = [];\n    private prevTime: number = 0;\n    private isDouble: boolean = false;\n\n    /**\n     *\n     */\n    constructor(targets: Array<Element | Window> | Element | Window, options: GestoOptions = {}) {\n        super();\n        const elements = [].concat(targets as any) as Array<Element | Window>;\n        this.options = {\n            checkInput: false,\n            container: elements.length > 1 ? window : elements[0],\n            preventRightClick: true,\n            preventDefault: true,\n            checkWindowBlur: false,\n            pinchThreshold: 0,\n            events: [\"touch\", \"mouse\"],\n            ...options,\n        };\n\n        const { container, events, checkWindowBlur } = this.options;\n\n        this.isTouch = events!.indexOf(\"touch\") > -1;\n        this.isMouse = events!.indexOf(\"mouse\") > -1;\n        this.targets = elements;\n\n        if (this.isMouse) {\n            elements.forEach(el => {\n                addEvent(el, \"mousedown\", this.onDragStart);\n            });\n            addEvent(container!, \"mousemove\", this.onDrag);\n            addEvent(container!, \"mouseup\", this.onDragEnd);\n            addEvent(container!, \"contextmenu\", this.onDragEnd);\n        }\n        if (checkWindowBlur) {\n            addEvent(window, \"blur\", this.onBlur);\n        }\n        if (this.isTouch) {\n            const passive = {\n                passive: false,\n            };\n            elements.forEach(el => {\n                addEvent(el, \"touchstart\", this.onDragStart, passive);\n            });\n            addEvent(container!, \"touchmove\", this.onDrag, passive);\n            addEvent(container!, \"touchend\", this.onDragEnd, passive);\n            addEvent(container!, \"touchcancel\", this.onDragEnd, passive);\n        }\n    }\n    /**\n     * The total moved distance\n     */\n    public getMovement(clients?: Client[]) {\n        return this.getCurrentStore().getMovement(clients) + this.clientStores.slice(1).reduce((prev, cur) => {\n            return prev + cur.movement;\n        },  0);\n    }\n    /**\n     * Whether to drag\n     */\n    public isDragging(): boolean {\n        return this.isDrag;\n    }\n    /**\n     * Whether to start drag\n     */\n    public isFlag(): boolean {\n        return this.flag;\n    }\n    /**\n     * Whether to start pinch\n     */\n    public isPinchFlag() {\n        return this.pinchFlag;\n    }\n    /**\n     * Whether to pinch\n     */\n    public isPinching() {\n        return this.isPinch;\n    }\n    /**\n     * If a scroll event occurs, it is corrected by the scroll distance.\n     */\n    public scrollBy(deltaX: number, deltaY: number, e: any, isCallDrag: boolean = true) {\n        if (!this.flag) {\n            return;\n        }\n        this.clientStores[0].move(deltaX, deltaY);\n        isCallDrag && this.onDrag(e, true);\n    }\n    /**\n     * Create a virtual drag event.\n     */\n    public move([deltaX, deltaY]: number[], inputEvent: any): TargetParam<OnDrag> {\n        const store = this.getCurrentStore();\n        const nextClients = store.prevClients;\n\n        return this.moveClients(nextClients.map(({ clientX, clientY }) => {\n            return {\n                clientX: clientX + deltaX,\n                clientY: clientY + deltaY,\n                originalClientX: clientX,\n                originalClientY: clientY,\n            };\n        }), inputEvent, true);\n    }\n    /**\n     * The dragStart event is triggered by an external event.\n     */\n    public triggerDragStart(e: any) {\n        this.onDragStart(e, false);\n    }\n    /**\n     * Set the event data while dragging.\n     */\n    public setEventDatas(datas: IObject<any>) {\n        const currentDatas = this.datas;\n\n        for (const name in datas) {\n            currentDatas[name] = datas[name];\n        }\n        return this;\n    }\n    /**\n     * Set the event data while dragging.\n     */\n    public getEventDatas() {\n        return this.datas;\n    }\n    /**\n     * Unset Gesto\n     */\n    public unset() {\n        const targets = this.targets;\n        const container = this.options.container!;\n\n        this.off();\n        removeEvent(window, \"blur\", this.onBlur);\n        if (this.isMouse) {\n            targets.forEach(target => {\n                removeEvent(target, \"mousedown\", this.onDragStart);\n            });\n            removeEvent(container, \"mousemove\", this.onDrag);\n            removeEvent(container, \"mouseup\", this.onDragEnd);\n            removeEvent(container, \"contextmenu\", this.onDragEnd);\n        }\n        if (this.isTouch) {\n            targets.forEach(target => {\n                removeEvent(target, \"touchstart\", this.onDragStart);\n            });\n            removeEvent(container, \"touchstart\", this.onDragStart);\n            removeEvent(container, \"touchmove\", this.onDrag);\n            removeEvent(container, \"touchend\", this.onDragEnd);\n            removeEvent(container, \"touchcancel\", this.onDragEnd);\n        }\n    }\n    public onDragStart = (e: any, isTrusted = true) => {\n        if (!this.flag && e.cancelable === false) {\n            return;\n        }\n        const { container, pinchOutside, preventRightClick, preventDefault, checkInput } = this.options;\n        const isTouch = this.isTouch;\n        const isDragStart = !this.flag;\n\n        if (isDragStart) {\n            const activeElement = document.activeElement as HTMLElement;\n            const target = e.target as HTMLElement;\n            const tagName = target.tagName.toLowerCase();\n            const hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;\n            const hasContentEditable = target.isContentEditable;\n\n            if (hasInput || hasContentEditable) {\n                if (checkInput || activeElement === target) {\n                    // force false or already focused.\n                    return false;\n                }\n                if (\n                    activeElement\n                    && hasContentEditable\n                    && activeElement.isContentEditable\n                    && activeElement.contains(target)\n                ) {\n                    return false;\n                }\n            } else if ((preventDefault || e.type === \"touchstart\") && activeElement) {\n                const activeTagName = activeElement.tagName;\n                if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {\n                    activeElement.blur();\n                }\n            }\n            this.clientStores = [new ClientStore(getEventClients(e))];\n            this.flag = true;\n            this.isDrag = false;\n            this.datas = {};\n\n            if (preventRightClick && (e.which === 3 || e.button === 2)) {\n                this.initDrag();\n                return false;\n            }\n            const result = this.emit(\"dragStart\", {\n                datas: this.datas,\n                inputEvent: e,\n                isTrusted,\n                ...this.getCurrentStore().getPosition(),\n            });\n            if (result === false) {\n                this.initDrag();\n            }\n            this.isDouble = now() - this.prevTime < 200;\n            this.flag && preventDefault && e.preventDefault();\n        }\n        if (!this.flag) {\n            return false;\n        }\n        let timer = 0;\n\n        if (isDragStart && isTouch && pinchOutside) {\n            timer = setTimeout(() => {\n                addEvent(container!, \"touchstart\", this.onDragStart, { passive: false });\n            });\n        }\n        if (!isDragStart && isTouch && pinchOutside) {\n            removeEvent(container!, \"touchstart\", this.onDragStart);\n        }\n        if (this.flag && isMultiTouch(e)) {\n            clearTimeout(timer);\n            if (isDragStart && (e.touches.length !== e.changedTouches.length)) {\n                return;\n            }\n            if (!this.pinchFlag) {\n                this.onPinchStart(e);\n            }\n        }\n\n    }\n    public onDrag = (e: any, isScroll?: boolean) => {\n        if (!this.flag) {\n            return;\n        }\n        const clients = getEventClients(e);\n        const result = this.moveClients(clients, e, false);\n\n        if (this.pinchFlag || result.deltaX || result.deltaY) {\n            this.emit(\"drag\", {\n                ...result,\n                isScroll: !!isScroll,\n                inputEvent: e,\n            });\n        }\n        if (this.pinchFlag) {\n            this.onPinch(e, clients);\n        }\n\n        this.getCurrentStore().addClients(clients);\n    }\n    public onDragEnd = (e?: any) => {\n        if (!this.flag) {\n            return;\n        }\n        const { pinchOutside, container } = this.options;\n        if (this.isTouch && pinchOutside) {\n            removeEvent(container!, \"touchstart\", this.onDragStart);\n        }\n\n        this.flag = false;\n\n        const position = this.getCurrentStore().getPosition();\n\n        const currentTime = now();\n        const isDouble = !this.isDrag && this.isDouble;\n\n        this.prevTime = this.isDrag || isDouble ? 0 : currentTime;\n\n        this.emit(\"dragEnd\", {\n            datas: this.datas,\n            isDouble,\n            isDrag: this.isDrag,\n            inputEvent: e,\n            ...position,\n        });\n        if (this.pinchFlag) {\n            this.onPinchEnd(e);\n        }\n        this.clientStores = [];\n    }\n    public onPinchStart(e: TouchEvent) {\n        const { pinchThreshold } = this.options;\n\n        if (this.isDrag && this.getMovement() > pinchThreshold!) {\n            return;\n        }\n        const store = new ClientStore(getEventClients(e));\n\n        this.pinchFlag = true;\n        this.clientStores.splice(0, 0, store);\n\n        const result = this.emit(\"pinchStart\", {\n            datas: this.datas,\n            angle: store.getAngle(),\n            touches: this.getCurrentStore().getPositions(),\n            ...store.getPosition(),\n            inputEvent: e,\n        });\n\n        if (result === false) {\n            this.pinchFlag = false;\n        }\n    }\n    public onPinch(e: TouchEvent, clients: Client[]) {\n        if (!this.flag || !this.pinchFlag || clients.length < 2) {\n            return;\n        }\n\n        const store = this.getCurrentStore();\n        this.isPinch = true;\n\n        this.emit(\"pinch\", {\n            datas: this.datas,\n            movement: this.getMovement(clients),\n            angle: store.getAngle(clients),\n            rotation: store.getRotation(clients),\n            touches: store.getPositions(clients),\n            scale: store.getScale(clients),\n            distance: store.getDistance(clients),\n            ...store.getPosition(clients),\n            inputEvent: e,\n        });\n    }\n    public onPinchEnd(e: TouchEvent) {\n        if (!this.pinchFlag) {\n            return;\n        }\n        const isPinch = this.isPinch;\n\n        this.isPinch = false;\n        this.pinchFlag = false;\n        const store = this.getCurrentStore();\n        this.emit(\"pinchEnd\", {\n            datas: this.datas,\n            isPinch,\n            touches: store.getPositions(),\n            ...store.getPosition(),\n            inputEvent: e,\n        });\n        this.isPinch = false;\n        this.pinchFlag = false;\n    }\n\n    private initDrag() {\n        this.clientStores = [];\n        this.pinchFlag = false;\n        this.flag = false;\n    }\n    private getCurrentStore() {\n        return this.clientStores[0];\n    }\n    private moveClients(clients: Client[], inputEvent: any, isAdd: boolean): TargetParam<OnDrag> {\n        const store = this.getCurrentStore();\n        const position = store[isAdd ? \"addClients\" : \"getPosition\"](clients);\n\n        this.isDrag = true;\n\n        return {\n            datas: this.datas,\n            ...position,\n            movement: this.getMovement(clients),\n            isDrag: this.isDrag,\n            isPinch: this.isPinch,\n            isScroll: false,\n            inputEvent,\n        };\n    }\n    private onBlur = () => {\n        this.onDragEnd();\n    }\n}\n\nexport default Gesto;\n"]},"metadata":{},"sourceType":"module"}