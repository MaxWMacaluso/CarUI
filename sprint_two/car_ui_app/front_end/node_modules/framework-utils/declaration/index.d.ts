export declare function prefixNames(prefix: string, ...classNames: string[]): string;
export declare function prefixCSS(prefix: string, css: string): string;
export declare function ref(target: any, name: string): (e: any) => void;
export declare function refs(target: any, name: string, i: number): (e: any) => void;
export declare function Properties(properties: any[], action: (prototype: any, property: string) => any): (component: any) => void;
export declare function withMethods(methods: string[], duplicate?: {
    [name: string]: string;
}): (prototype: any, propertyName: string) => void;
export declare type ParametersType<T, R> = T extends (...params: infer U) => any ? (...params: U) => R : never;
export declare type ExcludeInterface<T, U> = {
    [key in (Exclude<keyof T, keyof U>)]: T[key];
};
export declare type Entries<T extends {
    [key: string]: any;
}, U = keyof T> = U extends string ? [U, T[U]] : never;
export declare type ReverseKey<T extends string, U extends {
    [key: string]: any;
}, E = Entries<U>> = E extends [infer K, T] ? K : never;
export declare type MethodInterface<T, U extends T, R extends any, Duplicate extends {
    [key: string]: any;
} = {}> = {
    [key in keyof ExcludeInterface<T, Duplicate>]: T[key] extends (...params: any[]) => U ? ParametersType<T[key], R> : T[key];
} & {
    [key in Duplicate[keyof Duplicate]]: T[ReverseKey<key, Duplicate> & keyof T] extends (...params: any[]) => U ? ParametersType<T[ReverseKey<key, Duplicate> & keyof T], R> : T[ReverseKey<key, Duplicate> & keyof T];
};
